1. GC是什么？为什么要有GC?
   GC是垃圾收集的意思，内存处理编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显式操作方法。
2. XML包括哪些解释技术，区别是什么？
   DOM和SAX
   DOM将文档解析成一颗文档树，可在节点上进行遍历、增加、修改和删除。一次性读入内存，对内存消耗大。
   SAX自上而下解析文档，以事件进行驱动。不会一次性读入内存，对内存消耗小，不能读取任意结点，并且不能对节点进行增加、修改和删除。
3. switch语句能否作用在byte、long、String上？
   switch能作用在byte、char、short和int上，jdk1.7后可以作用在String上。
4. "=="和equals方法究竟有什么区别？
   ==和equals都可以比较地址。==是运算符，equals是方法，方法可以通过重写改变其行为，如String的equals方法就是比较字符串的内容。
5. 构造方法能否被重载和重写？
   构造方法不能被重写但是能被重载。
6. 面向对象的特征有哪些？
   封装、继承、多态和抽象
7. 抽象类和接口的区别？
   1. 抽象类是abstract class修饰，接口是interface修饰
   2. 抽象类可以有任意类型的属性，接口只能有静态常量修饰的属性
   3. 抽象类可以有普通方法和抽象方法，接口的方法都是抽象方法
   4. 抽象类和接口都不能实例化，但是抽象类有构造方法，接口没有构造方法
   5. 抽象类只能单根继承，接口可以多重实现
8. 内部类可以引用它的包含类的成员吗？有什么限制？
可以引用。如果需要指定当前类时要用外部类.this来引用。如果引用局部变量，需要将局部变量指定为final。
9. String s = new String("xyz");创建了几个String Object?二者之间有什么区别？
2个对象。"xyz"创建在字符串常量池(jdk1.7之后已经被移到堆中)，new String()创建在堆中。
10. try{}里面有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行？
会在return前执行
11. Integer与int的区别
Integer为包装类，int是基本数据类型。包装类拥有属性和方法，而基本数据类型没有，包装类可以通过intValue来转换成基本数据类型，也可以通过new Integer()将基本数据类型转换成包装类。在jdk1.5以后，包装类和基本数据类型可以实现自动转换。
12. sleep()和wait()有什么区别？
sleep是Thread类的方法,wait是Object类的方法。
sleep是到时间自动唤醒，wait需要其他线程来唤醒notify。
sleep不会释放同步锁,wait会释放同步锁。
sleep可以在任意方法中,wait只能用在同步方法或者同步块中。
Sleep()不会释放对象锁到时自动恢复，wait()会释放对象锁标志，让其他线程可以进入synchronized数据块，并把当前线程放入对象等待池中，当调用notify()/notifyAll()方法后，从对象等待池中移出任意一个线程并放入锁标志等待池(只有锁标志等待池中的线程能够获取锁标志)中，如果锁标志等待池中没有线程，则notify()不起作用，notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志池中，准备获取对象锁，进入运行状态。
![](http://oqnfoupsj.bkt.clouddn.com/17-7-22/23523565.jpg)
补充:
线程的阻塞状态分为三种：
1）等待阻塞：运行的线程执wait()方法,JVM会把该线程放入等待队列中
2）同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
3）其他阻塞：运行的线程执行sleep()或join方法，或者发出了I/O请求时,JVM会把该线程置为阻塞状态。当sleep()时间结束join()等待线程执行结束，或者I/O处理完毕时，线程重新转入可运行状态。
13. 同步和异步有何异同，在什么情况下分别使用它们？
同步指同一时间只能一个线程执行该方法，其他线程需要等待。异步指多个线程可以同时执行某个方法，并共享同一资源。
同步可以让访问的资源具有安全性，因为同一时间只能一个线程对其进行访问。但是效率不高。
异步对访问的资源会造成不稳定性，比如多个线程同时访问一个资源，一个线程在修改，一个线程在删除，一个线程在读取，这样可能会造成资源的混乱。但是由于同时运行，执行效率得到提高。
14. 启动一个线程是用run()还是start()?
start()方法启动线程，run方法是线程执行的方法。
15. java中有几种类型的流?jdk为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？
java中有两种流，分别是字节流、字符流，字节流继承于java.io.InputStream,java.io.OutputStream。字符流继承于java.io.Reader,java.io.Writer。
16. 字符流和字节流的区别？
字节流用于读取或写出二进制数据，比如图片、影像等数据。
字符流用于读取或写出字符数据，比如传输字符串。
所有数据都可以通过字节流来进行处理，不过如果是字符数据，用字节流还需要进行转换后输出，如果使用字符流可以方便数据的转换。
17. error和exception的区别？
error是系统错误，是代码不能处理的错误，比如内存溢出、堆栈溢出等
exception是程序异常，可以通过代码try-catch进行处理，比如空指针异常，数组越界等
18. 谈谈final,finally,finalize()的区别？
final是修饰符：可以修饰类(不能被继承)、属性(常量)和方法(不能被重写)
finally是异常处理块中的代码块，表示无论如何都会执行的代码块。
finalize是Object类的方法，该方法在对象被垃圾回收之前执行的方法，可以通过在该方法中将无用对象重新建立起与GC Roots上对象的联系，来逃脱一次内存回收，对于每个对象该方法只会被执行一次。
19. 当一个线程进入一个对象的一个synchronized方法后，其他线程是否可进入此对象的其他方法？
如果其他方法没有加synchronized的话是可以进入的。
20. 当一个对象被当作参数传递到一个方法后，此方法可以改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？
java中只有值传递，如果传递的对象，实际也是传递该对象的地址。
21. 作用域public,private,protected以及不写时的区别
public公共修饰符，表示任意类都可以访问
protected为受保护的修饰符，表示同类、同包以及不同包但是父子关系的是可以访问的
不写表示默认修饰符，或者称为package修饰符，该修饰符表示只有同类或同包下的类可以访问，出了这个包就不能访问了
private为私有修饰符,表示只有同类可以访问
22. 用最有效率的方法算出2*8等于几？
2 << 3
23. heap和stack有什么区别。
heap表示堆,stack表示栈，堆中放对象，栈中放引用变量，堆是一个无序空间，栈是先进后出的结构
24. 运行时异常与一般异常有什么区别？
运行时异常是指继承于RuntimeException的异常，这些异常在编译时可以不进行处理，当运行时如果出现问题才会抛出。如NullPointException、ArrayIndexOutOfBoundsException
一般异常也称为编译时异常，这些异常是继承Exception但又不属于RuntimeException的子类，程序如果出现这些异常，在编译时必须进行捕捉或抛出，否则编译无法通过，如IOException、FileNotFoundException
25. 垃圾回收的优点和原理。并考虑两种回收机制
Java语言一个显著的特点就是引入了垃圾回收机制，使C++程序员最头疼的内存管理问题迎刃而解，它使得Java程序员在编写程序时不再需要考虑内存管理，由于有个垃圾回收机制，Java中的对象不再有作用域的概念，只有对象的引用才有作用域。垃圾回收可以有效的防止内存泄漏,有效的使用内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。标记清除法，复制法，标记整理法，分代收集算法
26. 描述一下JVM加载class文件的原理机制?
JVM中类的装载是由ClassLoader和它的子类来实现的，Java ClassLoader是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。
27. 是否可以从一个static方法内部发出对非static方法的调用？
不能，除非先创建非static方法所在类的对象
28. 什么是java序列化，如何实现java序列化？
序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。
序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，实现该接口只是为了标注该对象是可以被序列化的，然后使用一个输出流(如:FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出到对象的载体(此处是文件)中(即保存其状态)，要恢复的话则用输入流。
29. Anonymous Inner Class(匿名内部类)是否可以继承其他类，是否可以实现接口？
匿名内部类可以继承类或实现接口，但不是显式的使用extends或implements来继承或实现。在使用匿名内部类时，必须继承一个类或者实现一个接口，但是两者不可兼得，不能定义构造函数，不能存在任何的静态成员变量和静态方法
30. ArrayList和Vector的区别，HashMap和HashTable的区别？
ArrayList是JDK1.2引入的集合类并且线程不安全，Vector是1.0引入的集合类并且线程安全，二者用法类似。
HashMap线程不安全且能放空值或空键，HashTable线程安全，不能放空值或空键。 