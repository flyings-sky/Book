##1.数数
###问题描述
围棋棋盘由横纵19*19条线组成，这些线共组成多少个正方形？
###思路分析
- 依次计算边长为1、2、...、18的正方形由多少个，然后求和
- 计算以某个点为右下角的正方形共有多少个？然后把所有点的正方形数相加。

##2.逻辑推理:完形填空
###问题描述
皇帝不是穷人，在守财奴中也有穷人，所以有一些(  )并不是(  )。
A.皇帝，皇帝 B.守财奴，守财奴
C.守财奴，皇帝 D.皇帝，守财奴
###思路分析
使用离散数学来分析这个题目
从题目的描述可以得出下面三个命题
p:这个人是皇帝
q:这个人是穷人
r:这个人是守财奴
皇帝不是穷人:p -> ~q
在守财奴之中也有穷人:Эx(x∈r^x∈q)
一个命题和它的逆否命题是等价的，所以：
p -> ~q  等价于 q -> ~p
所以
Эx(x∈r^x∈q)等价于Эx(x∈r^x∈~p)
答案为：存在一些人，这些人是守财奴并且不是皇帝
##3.字符串表达式的计算
a+b*(c-d)+e
逆波兰表达式：栈的典型应用
##4.最大连续子数组
###问题描述
给定一个数组A[0,...,n-1]，求A的连续子数组，使得子数组的和最大
例如：
数组：1,-2,3,10,-4,7,2,-5
最大子数组：3,10,-4,7,2
###解法
- 暴力法
- 分治法
- 分析法
- 动态规划法

###暴力法分析
1.直接求解A[i,...,j]的值：
0 <= i < n
i <= j < n
数组A的长度j-i+1最大为n
因此时间复杂度O(n^3)
####暴力法代码
```java

public static int MaxSubArray(int [] array,int length){
        int maxSum = array[0];
        int currSum;
        for (int i = 0; i < length; i++) {
            for (int j = i; j < length; j++) {
                currSum = 0;
                for (int k = i; k <= j ; k++) {
                    currSum += array[k];
                }
                if(currSum > maxSum){
                    maxSum = currSum;
                }
            }
        }
        return maxSum;
}

```
